import java.io.*;
import java.util.*;

class Solution {
  
  //This function checks whether or not a character in a string has already
  //been accounted for
  //false = Haven't seen one yet
  //true = Already found one
  public static boolean checkDuped(boolean alphabetHash[], char c) {        
    int pos = Character.getNumericValue(c) - 10;    
    if (alphabetHash[pos] == false) {
      alphabetHash[pos] = true;
      return false;
    }
    else
      return true;      
  }
  
  //Assumption: Not case-sensitive
  public static void main(String[] args) {  
    
    //So why did I create my own hash data structure? Why didn't I use a default one?
    //I would be at the mercy of the build in hash-function, so I have no way of knowing
    //whether or not the order will be preserved (it probably won't).
    //Time complexity: O(n)
    //Space complexity: O(c) since my hash data structure is of fixed size
    //Instead of a hash-like array, I can just count the # unique chars, create an array
    //of that size, and just manually go through said array
    //Time complexity of that: O(n*m), Space complexity: O(m), where m <= 26
    //Having slightly less space complexity in my eyes is NOT WORTH sacrificing run time for.
    
    
    //Set up hash array
    boolean alphabetHash[] = new boolean[26];
    
    String stuff = "aabbccddhhgg";  
    char finalString[] = new char[stuff.length()];
    int pos = 0;
    
    char curChar;    
    //what loop does:
    //-for each char in the string I'm checking
    //-check if it's already in the hash array. if not, change the hash array,
    //add it to the final String, and and return false
    //-else do nothing and return true;
    for (int i = 0; i < stuff.length(); ++i) {
      curChar = stuff.charAt(i);
      if (!checkDuped(alphabetHash, Character.toLowerCase(curChar))) {
        finalString[pos] = curChar;
        ++pos;
      }            
    }
    
    System.out.println(finalString);
  }
  
}