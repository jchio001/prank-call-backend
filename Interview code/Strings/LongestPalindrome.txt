import java.io.*;
import java.util.*;

class Solution {

  
  public static void main(String[] args) {  
    //Strings are immutable in java unlike C++.
    //It is impossible to change them WITHOUT creating new data structures
    //This forces me to use a char[] instead
    String reverseMe = "all";
    char chrArray[] = reverseMe.toCharArray();        
    System.out.println(longestPalindrome(chrArray));    
  }
    
  
  //brute force method. Run time O(n^3)
  //Faster method: Dynamic programming
  //even faster: Manacher's algorithm O(n);
  public static char[] longestPalindrome(char c[]) {
    
    char longestPal[] = null;
    int longestLen = 0;
    int subStrLen = 0;
    int startIndex = 0;
    int endIndex = 0;
    
    for (int i = 0; i < c.length; ++i) {
      for (int j = i; j < c.length; ++j) {                        
        if (isPalindrome(c, i, j)) {          
          subStrLen = j - i + 1;          
          if (subStrLen > longestLen) {
            longestLen = subStrLen;
            startIndex = i;
            endIndex = j;
          }
        }          
      }
    }      
    longestPal = Arrays.copyOfRange(c, startIndex, endIndex + 1);    
    return longestPal;
  }  
      
  
  public static boolean isPalindrome(char chrArray[], int start, int end) {    
    //end - start!
    int MeetMeHalfway = (end - start) / 2;     
    //Start from the front and start from the back
    //Go 1 character in until we hit the middle and compare each char as we're going in
    //Then we're done!    
    for (int i = 0; i <= MeetMeHalfway; ++i) {                        
      if (Character.toLowerCase(chrArray[start + i]) != Character.toLowerCase(chrArray[end - i]))
        return false;
    }
    return true;
    
  }
  
}